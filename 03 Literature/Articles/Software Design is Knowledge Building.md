---
tags:
  - type/article
  - status/day
  - software_design
  - theory_crafting
publication:
  - olano
source: https://olano.dev/blog/software-design-is-knowledge-building/
created: 2025-01-03
---
# Software Design is Knowledge Building

> [!abstract] Summary
> An article on the idea that the building of a program is the building of its theory, the knowledge held by the programmer, and this theory is required to maintain and modify the program. The viability of the program longterm is in its theory not its code.
## Highlights
---
> a seemingly **functional 6-month-old project ==automatically turns into a haunted forest just by changing hands.**== Regardless of its age, `SVC` is textbook legacy software because, more often than not, **==a question== posed about the system, to any team member, ==results in the same answer: _I don’t know_.**==

> The problem is that `TEAM` members ==**don’t have enough elements== to build a satisfactory mental model** of `SVC`. They need to go by a mix of the **client’s interpretation of ==what the system _should be_,== and what they can tell from the code that ==the system _actually is_.**==

> the common **==misconception== that software development consists of ==producing code;**== that, once working code exists, programmers should act as interchangeable operators of varying qualities

> **==Changes== made ==by people who do not understand== the original design** concept almost always **cause the structure of the ==program to degrade.**==

> After those changes, **one must ==know both the original design== rules, and the ==newly introduced exceptions== to the rules, to understand the product.** After many such changes, the original designers no longer understand the product. Those who made the changes, never did. In other words, ==**nobody understands== the modified product.**

> Parnas calls **“ignorant surgery”, the ==system degrading over time.**==

> Programming should be regarded as an activity by which the ==**programmers form== or achieve a certain kind of insight, a ==theory,**== of the matters at hand. This suggestion is ==**in contrast== to what appears to be a more common notion, that ==programming should be== regarded as a ==production of a program==** and certain other texts.

> the **==mental model== that allows the ==designer to map a subset of the world==** (the domain) to and from the system, and not the system itself, ==**is the primary product== of the software design** activity

> Thus **the ==programmer must be able to explain==, for each part of the program** text and for each of its overall structural characteristics, **what ==aspect or activity== of the world ==is matched== by it.**

> The programmer **having the ==theory== of the program ==can explain==** why each part of the program is what it is

> The programmer **having the ==theory== of the program is able to ==respond== constructively to any demand for a ==modification==** of the program so as to support the affairs of the world in a new manner.

> Naur defines ==**software design== as an intellectual activity, consisting of ==building and having a theory==**

> the ==**knowledge== a person must have in order not only ==to do== certain things intelligently** but also ==**to explain== them, ==to answer== queries about them**, to argue about them, and so forth.

> The ==**building of the program== is the same as the ==building of the theory==** of it by the team of programmers.

> The ==**death of a program happens when the programmer team possessing its theory is dissolved.**==

> ==**Revival== of a program ==is the rebuilding==** of its theory by a new programmer team.

> Knowing that revival is a plausible future need has powerful consequences for our work.

> the ultimate **goal of ==software design== should be (organizational) ==knowledge building.==**

> rather than thinking in terms of the burden on future maintainers, think: **how much will this decision affect—how much will it help or hinder—their ==building of a mental model==** of the system, of the business, of the world.
## Citation
---
```
"Software Design is Knowledge Building." olano. https://olano.dev/blog/software-design-is-knowledge-building
```
