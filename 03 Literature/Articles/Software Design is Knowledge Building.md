---
kind: article
links:
  - "[[systems thinking]]"
publication:
  - olano
source: https://olano.dev/blog/software-design-is-knowledge-building/
---
# Software Design is Knowledge Building

> [!abstract] Summary
> The building of a program is the building of the knowledge held by the programmer, called theory.  T theory is required to maintain and modify the program. The viability of the program longterm is in its theory not its code.
## Highlights
---
a seemingly **functional 6-month-old project ==automatically turns into a haunted forest just by changing hands.**== Regardless of its age, `SVC` is textbook legacy software because, more often than not, **==a question== posed about the system, to any team member, ==results in the same answer: _I don’t know_.**==

The problem is that `TEAM` members ==**don’t have enough elements== to build a satisfactory mental model** of `SVC`. They need to go by a mix of the **client’s interpretation of ==what the system _should be_,== and what they can tell from the code that ==the system _actually is_.**==

the common **==misconception== that software development consists of ==producing code;**== that, once working code exists, programmers should act as interchangeable operators of varying qualities

**=Changes== made ==by people who do not understand== the original design** concept almost always **cause the structure of the ==program to degrade.**==

After those changes, **one must ==know both the original design== rules, and the ==newly introduced exceptions== to the rules, to understand the product.** After many such changes, the original designers no longer understand the product. Those who made the changes, never did. In other words, ==**nobody understands== the modified product.**

Parnas calls **“ignorant surgery”, the ==system degrading over time.**==

Programming should be regarded as an activity by which the ==**programmers form== or achieve a certain kind of insight, a ==theory,**== of the matters at hand. This suggestion is ==**in contrast== to what appears to be a more common notion, that ==programming should be== regarded as a ==production of a program==** and certain other texts.

the **==mental model== that allows the ==designer to map a subset of the world==** (the domain) to and from the system, and not the system itself, ==**is the primary product== of the software design** activity

Thus **the ==programmer must be able to explain==, for each part of the program** text and for each of its overall structural characteristics, **what ==aspect or activity== of the world ==is matched== by it.**

The programmer **having the ==theory== of the program ==can explain==** why each part of the program is what it is

The programmer **having the ==theory== of the program is able to ==respond== constructively to any demand for a ==modification==** of the program so as to support the affairs of the world in a new manner.

Naur defines ==**software design== as an intellectual activity, consisting of ==building and having a theory==**

the ==**knowledge== a person must have in order not only ==to do== certain things intelligently** but also ==**to explain== them, ==to answer== queries about them**, to argue about them, and so forth.

The ==**building of the program== is the same as the ==building of the theory==** of it by the team of programmers.

The ==**death of a program happens when the programmer team possessing its theory is dissolved.**==

==**Revival== of a program ==is the rebuilding==** of its theory by a new programmer team.

Knowing that revival is a plausible future need has powerful consequences for our work.

the ultimate **goal of ==software design== should be (organizational) ==knowledge building.==**

rather than thinking in terms of the burden on future maintainers, think: **how much will this decision affect—how much will it help or hinder—their ==building of a mental model==** of the system, of the business, of the world.
## Citation
---
```
"Software Design is Knowledge Building." olano. https://olano.dev/blog/software-design-is-knowledge-building
```
